// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package playlistsbytallinn

import (
	"context"
	"github.com/murdho/playlists-by-tallinn/track"
	"sync"
)

var (
	lockRadioMockCurrentTrack sync.RWMutex
)

// Ensure, that RadioMock does implement Radio.
// If this is not the case, regenerate this file with moq.
var _ Radio = &RadioMock{}

// RadioMock is a mock implementation of Radio.
//
//     func TestSomethingThatUsesRadio(t *testing.T) {
//
//         // make and configure a mocked Radio
//         mockedRadio := &RadioMock{
//             CurrentTrackFunc: func() (string, error) {
// 	               panic("mock out the CurrentTrack method")
//             },
//         }
//
//         // use mockedRadio in code that requires Radio
//         // and then make assertions.
//
//     }
type RadioMock struct {
	// CurrentTrackFunc mocks the CurrentTrack method.
	CurrentTrackFunc func() (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// CurrentTrack holds details about calls to the CurrentTrack method.
		CurrentTrack []struct {
		}
	}
}

// CurrentTrack calls CurrentTrackFunc.
func (mock *RadioMock) CurrentTrack() (string, error) {
	if mock.CurrentTrackFunc == nil {
		panic("RadioMock.CurrentTrackFunc: method is nil but Radio.CurrentTrack was just called")
	}
	callInfo := struct {
	}{}
	lockRadioMockCurrentTrack.Lock()
	mock.calls.CurrentTrack = append(mock.calls.CurrentTrack, callInfo)
	lockRadioMockCurrentTrack.Unlock()
	return mock.CurrentTrackFunc()
}

// CurrentTrackCalls gets all the calls that were made to CurrentTrack.
// Check the length with:
//     len(mockedRadio.CurrentTrackCalls())
func (mock *RadioMock) CurrentTrackCalls() []struct {
} {
	var calls []struct {
	}
	lockRadioMockCurrentTrack.RLock()
	calls = mock.calls.CurrentTrack
	lockRadioMockCurrentTrack.RUnlock()
	return calls
}

var (
	lockTrackStorageMockLoad sync.RWMutex
	lockTrackStorageMockSave sync.RWMutex
)

// Ensure, that TrackStorageMock does implement TrackStorage.
// If this is not the case, regenerate this file with moq.
var _ TrackStorage = &TrackStorageMock{}

// TrackStorageMock is a mock implementation of TrackStorage.
//
//     func TestSomethingThatUsesTrackStorage(t *testing.T) {
//
//         // make and configure a mocked TrackStorage
//         mockedTrackStorage := &TrackStorageMock{
//             LoadFunc: func(ctx context.Context, name string) (*track.Track, error) {
// 	               panic("mock out the Load method")
//             },
//             SaveFunc: func(ctx context.Context, track track.Track) error {
// 	               panic("mock out the Save method")
//             },
//         }
//
//         // use mockedTrackStorage in code that requires TrackStorage
//         // and then make assertions.
//
//     }
type TrackStorageMock struct {
	// LoadFunc mocks the Load method.
	LoadFunc func(ctx context.Context, name string) (*track.Track, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, track track.Track) error

	// calls tracks calls to the methods.
	calls struct {
		// Load holds details about calls to the Load method.
		Load []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Track is the track argument value.
			Track track.Track
		}
	}
}

// Load calls LoadFunc.
func (mock *TrackStorageMock) Load(ctx context.Context, name string) (*track.Track, error) {
	if mock.LoadFunc == nil {
		panic("TrackStorageMock.LoadFunc: method is nil but TrackStorage.Load was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	lockTrackStorageMockLoad.Lock()
	mock.calls.Load = append(mock.calls.Load, callInfo)
	lockTrackStorageMockLoad.Unlock()
	return mock.LoadFunc(ctx, name)
}

// LoadCalls gets all the calls that were made to Load.
// Check the length with:
//     len(mockedTrackStorage.LoadCalls())
func (mock *TrackStorageMock) LoadCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	lockTrackStorageMockLoad.RLock()
	calls = mock.calls.Load
	lockTrackStorageMockLoad.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *TrackStorageMock) Save(ctx context.Context, track track.Track) error {
	if mock.SaveFunc == nil {
		panic("TrackStorageMock.SaveFunc: method is nil but TrackStorage.Save was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Track track.Track
	}{
		Ctx:   ctx,
		Track: track,
	}
	lockTrackStorageMockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	lockTrackStorageMockSave.Unlock()
	return mock.SaveFunc(ctx, track)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//     len(mockedTrackStorage.SaveCalls())
func (mock *TrackStorageMock) SaveCalls() []struct {
	Ctx   context.Context
	Track track.Track
} {
	var calls []struct {
		Ctx   context.Context
		Track track.Track
	}
	lockTrackStorageMockSave.RLock()
	calls = mock.calls.Save
	lockTrackStorageMockSave.RUnlock()
	return calls
}

var (
	lockLoggerMockDebug sync.RWMutex
	lockLoggerMockInfow sync.RWMutex
)

// Ensure, that LoggerMock does implement Logger.
// If this is not the case, regenerate this file with moq.
var _ Logger = &LoggerMock{}

// LoggerMock is a mock implementation of Logger.
//
//     func TestSomethingThatUsesLogger(t *testing.T) {
//
//         // make and configure a mocked Logger
//         mockedLogger := &LoggerMock{
//             DebugFunc: func(args ...interface{})  {
// 	               panic("mock out the Debug method")
//             },
//             InfowFunc: func(msg string, keysAndValues ...interface{})  {
// 	               panic("mock out the Infow method")
//             },
//         }
//
//         // use mockedLogger in code that requires Logger
//         // and then make assertions.
//
//     }
type LoggerMock struct {
	// DebugFunc mocks the Debug method.
	DebugFunc func(args ...interface{})

	// InfowFunc mocks the Infow method.
	InfowFunc func(msg string, keysAndValues ...interface{})

	// calls tracks calls to the methods.
	calls struct {
		// Debug holds details about calls to the Debug method.
		Debug []struct {
			// Args is the args argument value.
			Args []interface{}
		}
		// Infow holds details about calls to the Infow method.
		Infow []struct {
			// Msg is the msg argument value.
			Msg string
			// KeysAndValues is the keysAndValues argument value.
			KeysAndValues []interface{}
		}
	}
}

// Debug calls DebugFunc.
func (mock *LoggerMock) Debug(args ...interface{}) {
	if mock.DebugFunc == nil {
		panic("LoggerMock.DebugFunc: method is nil but Logger.Debug was just called")
	}
	callInfo := struct {
		Args []interface{}
	}{
		Args: args,
	}
	lockLoggerMockDebug.Lock()
	mock.calls.Debug = append(mock.calls.Debug, callInfo)
	lockLoggerMockDebug.Unlock()
	mock.DebugFunc(args...)
}

// DebugCalls gets all the calls that were made to Debug.
// Check the length with:
//     len(mockedLogger.DebugCalls())
func (mock *LoggerMock) DebugCalls() []struct {
	Args []interface{}
} {
	var calls []struct {
		Args []interface{}
	}
	lockLoggerMockDebug.RLock()
	calls = mock.calls.Debug
	lockLoggerMockDebug.RUnlock()
	return calls
}

// Infow calls InfowFunc.
func (mock *LoggerMock) Infow(msg string, keysAndValues ...interface{}) {
	if mock.InfowFunc == nil {
		panic("LoggerMock.InfowFunc: method is nil but Logger.Infow was just called")
	}
	callInfo := struct {
		Msg           string
		KeysAndValues []interface{}
	}{
		Msg:           msg,
		KeysAndValues: keysAndValues,
	}
	lockLoggerMockInfow.Lock()
	mock.calls.Infow = append(mock.calls.Infow, callInfo)
	lockLoggerMockInfow.Unlock()
	mock.InfowFunc(msg, keysAndValues...)
}

// InfowCalls gets all the calls that were made to Infow.
// Check the length with:
//     len(mockedLogger.InfowCalls())
func (mock *LoggerMock) InfowCalls() []struct {
	Msg           string
	KeysAndValues []interface{}
} {
	var calls []struct {
		Msg           string
		KeysAndValues []interface{}
	}
	lockLoggerMockInfow.RLock()
	calls = mock.calls.Infow
	lockLoggerMockInfow.RUnlock()
	return calls
}
